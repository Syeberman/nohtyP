import os.path, itertools
import SCons.Errors

# TODO support scons -h for build options

# Confirm that scons' top-level directory, the current directory, _is_ the project top
if not os.path.exists( "nohtyP.c" ):
    Exit( "Run SCons from top project dir (or use make.bat, or scons -C)" )


# Adds nohtyP.dll/libnotyP.so/etc as a target in env
def nohtyP_SharedLibrary( env ):
    env.PrependUnique(
            CPPPATH=[
                "#",
                ],
            CPPDEFINES=[
                "yp_ENABLE_SHARED",
                "yp_BUILD_CORE",
                "yp_DEBUG_LEVEL=%s" % ("1" if env["CONFIGURATION"] == "debug" else "0"),
                ],
            PDB="$VTOP/nohtyP.pdb", LIBS="",
            )
    return env.SharedLibrary( "$VTOP/nohtyP", source="$VTOP/nohtyP.c" ),


# Command-line build variables
vars = Variables( None )

# Generic build environment applicable to all compilers/targets and used internally by SCons
rootEnv = DefaultEnvironment( tools=[], variables=vars )

# Require that only known command-line variables are used
vars_unknown = vars.UnknownVariables( )
if vars_unknown: Exit( "Unknown variables: %r" % vars_unknown.keys( ) )

# Require that construction variable names exist at expansion, then add those allowed to be empty
AllowSubstExceptions( )
rootEnv.Replace( CPPFLAGS=[], SHCCCOMSTR="", SHLINKCOMSTR="", SHLIBVERSION="", LIBPATH=[], PCH="",
        WINDOWS_INSERT_DEF=0, WINDOWSDEFPREFIX="", WINDOWSDEFSUFFIX="" )

# Put .sconsign.dblite (et al) in Build rather than the top nohtyP directory
rootEnv.SConsignFile( os.path.abspath( "Build/.sconsign" ) )

# For dependencies, first consider timestamps, then MD5 checksums
rootEnv.Decider( "MD5-timestamp" )

# Always use cmd.exe on Windows, regardless of user's shell; ignored on other platforms
rootEnv["ENV"]["COMSPEC"] = "cmd.exe"

# TODO Scripts to update version numbers in source, build scripts, etc
rootEnv.Replace( NOHTYP_MAJOR=0, NOHTYP_MINOR=5, NOHTYP_PATCH=0 )


# Site-specific tool configuration.  For some tools, this caches the results of lengthy
# auto-detection; for other tools that don't have version-dependent auto-detect, this allows the
# user to tell us where they put the other versions.
siteTools_name = os.path.abspath( "Build/site-tools.py" )
siteTools_dict = {}
if not os.path.exists( siteTools_name ):
    with open( siteTools_name, "w" ) as outfile:
        outfile.write( "# Holds site-specific configuration options for the compilers and other tools.\n" )
        outfile.write( "# Edit as appropriate.  Missing entries added automatically.  Rebuilt if deleted.\n\n" )
else:
    with open( siteTools_name ) as infile:
        exec( infile.read( ), siteTools_dict )
def siteToolsFunction( ):
    """Returns the file name of site-tools.py, and a dictionary of current variables."""
    return siteTools_name, siteTools_dict
rootEnv["SITE_TOOLS"] = siteToolsFunction # a function so Clone doesn't deepcopy it


# List these in order of decreasing "preference"; the first variant that matches will be chosen as
# "native" (ie the default target)
# TODO Allow the user to specify what the "native" target should be
compiler_names = ("msvs_120", "gcc_48", "msvs_110", "msvs_100", "msvs_90")
oses = ("win32", )
archs = ("amd64", "x86")
# TODO An "analyze" configuration to use the compiler's static analysis, "lint" to explicitly use
# lint agains the compiler's headers
configurations = ("release", "debug")

native_os = rootEnv["PLATFORM"]
# TODO HOST_ARCH not supported outside of Windows
if rootEnv["HOST_ARCH"] == "x86_64":
    native_archs = ("amd64", "x86")
else:
    native_archs = (rootEnv["HOST_ARCH"], )

# The native targets ("debug", "release", etc) should each copy files from a single variant
nativeTargetsCreated = set( )

for compiler_name in compiler_names:
    # FIXME does this even speed things up?
    compiler = Tool( compiler_name, toolpath=["Build/Tools", ] )
    if not compiler.exists( rootEnv ): continue

    for os, arch, configuration in itertools.product( oses, archs, configurations ):
        # TODO Support cross-compiling OSes, if possible
        if os != native_os: continue

        # Maintain a separate directory for intermediate and target files, but don't copy files
        variantEnv = rootEnv.Clone( tools=[], COMPILER=compiler,
                TARGET_OS=os, TARGET_ARCH=arch, CONFIGURATION=configuration )
        variantEnv["VTOP"] = "#Build/%s/%s_%s_%s" % (compiler_name, os, arch, configuration)
        variantEnv.VariantDir( "$VTOP", "#", duplicate=False )

        # Skip compilers that can't be found (TODO unless we want an error in that case?)
        # TODO: This script is slow due to vcvarsall.bat executing 52 times; cache in SCons
        # TODO: Record compiler version information in the variant directory
        try:
            compilerEnv = variantEnv.Clone( tools=[compiler, ] )
        except (SCons.Errors.UserError, SCons.Errors.StopError): continue

        targets = []
        targets.append( nohtyP_SharedLibrary( compilerEnv.Clone( ) ) )

        # Pick one variant from each configuration that matches the host system, and copy it to the
        # Build/native directory for easy access
        if os == native_os and arch in native_archs:
            if configuration not in nativeTargetsCreated:
                if configuration == "release":
                    native_dest = "#Build/native"
                else:
                    native_dest = "#Build/native/%s" % configuration
                native_target = variantEnv.Install( native_dest, targets )
                targets.append( native_target )
                Alias( configuration, native_target )
                Alias( "native", native_target )
                nativeTargetsCreated.add( configuration )

        Alias( "all", targets )
        Alias( compiler_name, targets )
        Alias( "_".join( (compiler_name, os) ), targets )
        Alias( "_".join( (compiler_name, os, arch) ), targets )
        Alias( "_".join( (compiler_name, os, arch, configuration) ), targets )

# If SCons is called without targets, build the "native" target
Default( Alias( "native" ) )

