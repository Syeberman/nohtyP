import os.path, itertools
import SCons.Errors

# TODO support scons -h for build options

# Confirm that scons' top-level directory, the current directory, _is_ the project top
if not os.path.exists( "nohtyP.c" ):
    Exit( "Run SCons from top project dir (or use make.bat, or scons -C)" )


# Adds nohtyP.dll/libnotyP.so/etc as a target in env
def nohtyP_SharedLibrary( env ):
    env.PrependUnique(
            CPPPATH=[
                "#",
                ],
            CPPDEFINES=[
                "yp_ENABLE_SHARED",
                "yp_BUILD_CORE",
                "yp_DEBUG_LEVEL=%s" % ("1" if env["CONFIGURATION"] == "debug" else "0"),
                ],
            PDB="$VTOP/nohtyP.pdb", LIBS="",
            )
    return env.SharedLibrary( "$VTOP/nohtyP", source="$VTOP/nohtyP.c" ),

def nohtyP_yp_test( env, sharedLib ):
    env.PrependENVPath( "PYTHONPATH", "#/Lib" )
    env.PrependENVPath( "PATH", Flatten( sharedLib )[0].get_dir( ) )
    scripts = ("#/Lib/yp.py", Glob("#/Lib/yp_test/*.py"), Glob("#/Lib/yp_test/*.txt"))
    testLog = env.Command( "$VTOP/yp_test.log", (sharedLib, scripts),
            "python -m yp_test -v > $TARGET" )
    Clean( sharedLib, testLog )
    return testLog


# Command-line build variables
vars = Variables( None )

# Generic build environment applicable to all compilers/targets and used internally by SCons
rootEnv = DefaultEnvironment( tools=[], variables=vars )

# Require that only known command-line variables are used
vars_unknown = vars.UnknownVariables( )
if vars_unknown: Exit( "Unknown variables: %r" % vars_unknown.keys( ) )

# Require that construction variable names exist at expansion, then add those allowed to be empty
AllowSubstExceptions( )
rootEnv.Replace( CPPFLAGS=[], SHCCCOMSTR="", SHLINKCOMSTR="", SHLIBVERSION="", LIBPATH=[], PCH="",
        WINDOWS_INSERT_DEF=0, WINDOWSDEFPREFIX="", WINDOWSDEFSUFFIX="" )

# Put .sconsign.dblite (et al) in Build rather than the top nohtyP directory
rootEnv.SConsignFile( os.path.abspath( "Build/.sconsign" ) )

# For dependencies, first consider timestamps, then MD5 checksums
rootEnv.Decider( "MD5-timestamp" )

# Always use cmd.exe on Windows, regardless of user's shell; ignored on other platforms
rootEnv["ENV"]["COMSPEC"] = "cmd.exe"

# TODO Scripts to update version numbers in source, build scripts, etc
rootEnv.Replace( NOHTYP_MAJOR=0, NOHTYP_MINOR=5, NOHTYP_PATCH=0 )


# Site-specific tool configuration.  For some tools, this caches the results of lengthy
# auto-detection; for other tools that don't have version-dependent auto-detect, this allows the
# user to tell us where they put the other versions.
siteTools_name = os.path.abspath( "Build/site-tools.py" )
siteTools_dict = {}
if not os.path.exists( siteTools_name ):
    with open( siteTools_name, "w" ) as outfile:
        outfile.write( "# Holds site-specific configuration options for the compilers and other tools.\n" )
        outfile.write( "# Edit as appropriate.  Missing entries added automatically.  Rebuilt if deleted.\n\n" )
else:
    with open( siteTools_name ) as infile:
        exec( infile.read( ), siteTools_dict )
def siteToolsFunction( ):
    """Returns the file name of site-tools.py, and a dictionary of current variables."""
    return siteTools_name, siteTools_dict
rootEnv["SITE_TOOLS"] = siteToolsFunction # a function so Clone doesn't deepcopy it


# List these in order of decreasing "preference"; the first variant that matches will be chosen as
# "native" (ie the default target)
# TODO Allow the user to specify what the "native" target should be
compiler_names = ("msvs_120", "gcc_48", "msvs_110", "msvs_100", "msvs_90")
oses = ("win32", )
archs = ("amd64", "x86")
# TODO An "analyze" configuration to use the compiler's static analysis, "lint" to explicitly use
# lint agains the compiler's headers
configurations = ("release", "debug")

native_os = rootEnv["PLATFORM"]
# TODO HOST_ARCH not supported outside of Windows
if rootEnv["HOST_ARCH"] == "x86_64":
    native_archs = ("amd64", "x86")
else:
    native_archs = (rootEnv["HOST_ARCH"], )

# The native targets ("debug", "release", etc) should each copy files from a single variant
nativeTargetsToCreate = set( ("release", "debug") )

# yp_test requires at least Python 3.3
python_min33 = Tool( "python_min33", toolpath=["Build/Tools", ] )

for compiler_name in compiler_names:
    compiler = Tool( compiler_name, toolpath=["Build/Tools", ] )
    if not compiler.exists( rootEnv ): continue

    for targ_os, targ_arch, configuration in itertools.product( oses, archs, configurations ):
        # TODO Support cross-compiling OSes, if possible
        if targ_os != native_os: continue

        # Maintain a separate directory for intermediate and target files, but don't copy files
        variantEnv = rootEnv.Clone( COMPILER=compiler,
                TARGET_OS=targ_os, TARGET_ARCH=targ_arch, CONFIGURATION=configuration )
        variantEnv["VTOP"] = "#Build/%s/%s_%s_%s" % (
                compiler_name, targ_os, targ_arch, configuration)
        variantEnv.VariantDir( "$VTOP", "#", duplicate=False )

        # Skip compilers that can't be found
        try: compilerEnv = variantEnv.Clone( tools=[compiler, ] )
        except (SCons.Errors.UserError, SCons.Errors.StopError): continue

        buildTargets = []
        testTargets = []
        
        sharedLib = nohtyP_SharedLibrary( compilerEnv.Clone( ) )
        buildTargets.append( sharedLib )

        if targ_os == native_os and targ_arch in native_archs:
            # We can only run yp_test on native OS and architectures, and only if a version
            # of Python exists that can run against the target architecture.  Include sharedLib
            # in testTargets so that "testrelease" will pull them into the native directory.
            try: testTargets.extend( (
                    nohtyP_yp_test( variantEnv.Clone( tools=[python_min33, ] ), sharedLib ),
                    sharedLib ) )
            except (SCons.Errors.UserError, SCons.Errors.StopError): continue

            # Pick one variant from each configuration that matches the host system, and copy it 
            # to the Build/native directory for easy access
            if configuration in nativeTargetsToCreate:
                if configuration == "release":
                    native_dest = "#Build/native"
                else:
                    native_dest = "#Build/native/"+configuration
                buildTargets.append( variantEnv.Install( native_dest, buildTargets ) )
                testTargets.append( variantEnv.Install( native_dest, testTargets ) )
                Alias( configuration, buildTargets )
                Alias( "test"+configuration, testTargets )
                Alias( "native", buildTargets )
                Alias( "test", testTargets )
                nativeTargetsToCreate.remove( configuration )

        Alias( "all", buildTargets )
        Alias( "testall", testTargets )
        heirarchy = (compiler_name, targ_os, targ_arch, configuration)
        for heirarchyDepth in range( 1, len( heirarchy ) ):
            heirarchyName = "_".join( heirarchy[:heirarchyDepth] )
            Alias( heirarchyName, buildTargets )
            Alias( "test"+heirarchyName, testTargets )

# The default for "scons -c" is to clean the entire Build directory; otherwise, the default is to 
# build just the native targets
if GetOption( "clean" ): Default( "#Build" )
else: Default( Alias( "native" ) )

