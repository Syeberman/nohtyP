import os
import os.path
import itertools
import traceback
import SCons.Errors

# Confirm that scons' top-level directory, the current directory, _is_ the project top
if not os.path.exists("nohtyP.c"):
    Exit("Run SCons from top project dir (or use Build/make, or scons -C)")

# TODO Scripts to update version numbers in source, build scripts, etc
RootEnv.Replace(NOHTYP_MAJOR=0, NOHTYP_MINOR=5, NOHTYP_PATCH=0)


# TODO Can these be moved into root_environment.py?
def get_implib(env, target):
    return env.FindIxes(target, 'LIBPREFIX', 'LIBSUFFIX')

def get_dll(env, target):
    return env.FindIxes(target, 'SHLIBPREFIX', 'SHLIBSUFFIX')

def get_prog(env, target):
    return env.FindIxes(target, "PROGPREFIX", "PROGSUFFIX")


# Adds nohtyP.dll/libnotyP.so/etc as a target in env
# TODO Combine nohtyP.c and nohtyP.cs into a single DLL
#   https://blogs.msdn.microsoft.com/junfeng/2005/05/19/how-do-i-mix-c-and-c-code-in-a-single-assembly/
def nohtyP_SharedLibrary(env):
    env.PrependUnique(
        CPPPATH=[
            "#",
        ],
        CPPDEFINES=[
            "yp_ENABLE_SHARED",
            "yp_BUILD_CORE",
            "yp_DEBUG_LEVEL=%s" % ("10" if env["CONFIGURATION"] == "debug" else "0"),
        ],
        LIBS=[],
    )
    env.Replace(PDB="$VTOP/nohtyP.pdb")
    return env.SharedLibrary("$VTOP/nohtyP", source="$VTOP/nohtyP.c")


# Builds the munit_test suite against the shared library.
def nohtyP_munit_test_Program_shared(env, sharedLib):
    env.PrependUnique(
        CPPPATH=[
            "#",
            "#/Lib",
            "#/Tools/munit",
        ],
        CPPDEFINES=[
            "yp_ENABLE_SHARED",
            # TODO munit assertion failures go to stderr, status updates to MUNIT_OUTPUT_FILE. We
            # can configure status updates, but not failures. Contribute a patch to put everything
            # to stdout. (Errors running the tests should still go to stderr.)
            # FIXME Just write it to two separate files, since they don't play nice combined.
            "MUNIT_OUTPUT_FILE=stderr"
        ],
        LIBS=[
            get_implib(env, sharedLib),
            # Fixes `libnohtyP.so: undefined reference to `pow'` on Ubuntu 20.04.
            "m" if env["TARGET_OS"] == "posix" else "",
        ],
    )
    env.Replace(
        PDB="$VTOP/munit_test.pdb", CCCOMSTR="Compiling $TARGET", LINKCOMSTR="Linking $TARGET"
    )
    source = [
        # TODO Add ypExample.c to the munit tests.
        env.Glob("$VTOP/Lib/munit_test/*.c"),
        env.Glob("$VTOP/Lib/munit_test/*/*.c"),
        "$VTOP/Tools/munit/munit.c"
    ]
    return env.Program("$VTOP/munit_test", source=source)


def nohtyP_yp_test(env, sharedLib):
    env.PrependENVPath("PYTHONPATH", "#/Lib")
    env["ENV"]["NOHTYP_LIBRARY"] = get_dll(env, sharedLib)
    scripts = ("#/Lib/yp.py", env.Glob("#/Lib/yp_test/*.py"), env.Glob("#/Lib/yp_test/*.txt"))
    testLog = env.Command(
        "$VTOP/yp_test.log", (sharedLib, scripts), "$PYTHON -m yp_test -v > $TARGET"
    )
    Clean(sharedLib, testLog)
    return testLog


# Runs the munit_test suite.
def nohtyP_munit_test(env, munit_test):
    env["MUNIT_TEST"] = get_prog(env, munit_test)
    testLog = env.Command(
        # TODO See MUNIT_OUTPUT_FILE comment above.
        "$VTOP/munit_test.log",
        (munit_test),
        "$MUNIT_TEST 2> $TARGET"
    )
    Clean(munit_test, testLog)
    return testLog


def nohtyP_checkapi(env):
    # nohtyP.h contains very few PP conditionals, so not much needs to be set up. Preprocessed
    # only recognizes .c (etc) files so we make a copy with that extension. Use dummy versions
    # of standard headers that work well with pycparser.
    env.PrependUnique(CPPPATH=["#", "#/Include/fake_libc_include"], PDB="", LIBS="")
    headerDotC = env.Command(
        "$VTOP/checkapi/nohtyP_h.c", "$VTOP/nohtyP.h", Copy("$TARGET", "$SOURCE")
    )
    preprocessed = env.Preprocessed("$VTOP/checkapi/nohtyP_h", source=headerDotC)

    # TODO Have checkapi write directly to the file
    scripts = (env.Glob("#/Tools/checkapi/*.py"), )
    checkapiLog = env.Command(
        "$VTOP/checkapi.log", (preprocessed, scripts),
        "$PYTHON Tools/checkapi/checkapi.py $SOURCE > $TARGET"
    )
    return checkapiLog


# List these in order of decreasing "preference"; the first variant that matches will be chosen as
# "build" (ie the default target)
# TODO If none of these compilers can be found, default to an "any" compiler (but still version the
# output directory)
# TODO Would love to make this more dynamic, finding any known compiler, and then trimming.
# TODO Visual Studio 2022, 2019, 2017 support
# TODO Clang/LLVM support
# TODO GCC 6 can't be found on AppVeyor's Ubuntu1604
compiler_names = (
    "msvs_158", "gcc_10", "gcc_9", "gcc_8", "gcc_7", "msvs_140", "gcc_6", "gcc_5", "msvs_120",
    "gcc_49", "gcc_48", "msvs_110", "gcc_47", "gcc_46", "msvs_100", "msvs_90"
)
oses = ("win32", "posix", "darwin")
archs = ("amd64", "x86")
# TODO An "analyze" configuration to use the compiler's static analysis, "lint" to explicitly use
# lint against the compiler's headers
configurations = ("debug", "release")

native_os = RootEnv["HOST_OS"]
if RootEnv["HOST_ARCH"] == "x86_64":
    native_archs = ("amd64", "x86")
else:
    native_archs = (RootEnv["HOST_ARCH"], )

# The native targets ("debug", "release", etc) should each copy files from a single variant
nativeTargetsToCreate = set(("debug", "release"))

python_3 = Tool("python_3")
python_min_38 = Tool("python_min_38")  # yp_test requires at least Python 3.8
pclint = Tool("pclint")

SconscriptLog.write("""
Native OS: {native_os}
Native Arches: {native_archs}
""".format(**locals()))

# TODO support scons -h for build options

for compiler_name in compiler_names:
    compiler = Tool(compiler_name)

    for targ_os, targ_arch, configuration in itertools.product(oses, archs, configurations):
        # TODO Support cross-compiling OSes, if possible
        if targ_os != native_os:
            continue

        SconscriptLog.write(
            "\n{compiler_name} {targ_os} {targ_arch} {configuration}\n".format(**locals())
        )

        # Maintain a separate directory for intermediate and target files, but don't copy source
        variantEnv = RootEnv.Clone(
            COMPILER=compiler, TARGET_OS=targ_os, TARGET_ARCH=targ_arch, CONFIGURATION=configuration
        )
        variantEnv["VTOP"
                   ] = "#Build/%s/%s_%s_%s" % (compiler_name, targ_os, targ_arch, configuration)
        variantEnv.VariantDir("$VTOP", "#", duplicate=False)

        # Skip compilers that can't be found
        try:
            compilerEnv = variantEnv.Clone(tools=[compiler])
        except (SCons.Errors.UserError, SCons.Errors.StopError):
            traceback.print_exc(file=SconscriptLog)
            continue

        # These collect all the build, test, and analysis targets, including:
        #   - the C and C# builds of the nohtyP shared library
        #   - yp_test and ypExamples results
        #   - checkapi.py, PC-lint, expanded compiler warnings
        #   - targets that copy the above to Build/native
        buildTargets = []
        testTargets = []
        analyzeTargets = []

        sharedLib = nohtyP_SharedLibrary(compilerEnv.Clone())
        buildTargets.append(sharedLib)

        try:
            analyzeTargets.append(nohtyP_checkapi(compilerEnv.Clone(tools=[
                python_3,
            ])))
        except (SCons.Errors.UserError, SCons.Errors.StopError):
            traceback.print_exc(file=SconscriptLog)

        if targ_os == native_os and targ_arch in native_archs:
            # We can only run munit_test on native OS and architectures.
            testTargets.extend((
                nohtyP_munit_test(
                    variantEnv.Clone(),
                    nohtyP_munit_test_Program_shared(compilerEnv.Clone(), sharedLib)
                )
            ))

            # yp_test can only run if a version of Python exists that can run against the target
            # architecture. Include sharedLib in testTargets so that "test:release" will pull them
            # into the native directory.
            try:
                testTargets.extend((
                    nohtyP_yp_test(variantEnv.Clone(tools=[
                        python_min_38,
                    ]), sharedLib), sharedLib
                ))
            except (SCons.Errors.UserError, SCons.Errors.StopError):
                traceback.print_exc(file=SconscriptLog)

            # Pick one variant from each configuration that matches the host system, and copy it
            # to the Build/native directory for easy access. nativeTargetsToCreate tracks which
            # configurations we have yet to pick.
            if configuration in nativeTargetsToCreate:
                nativeTargetsToCreate.remove(configuration)
                if configuration == "release":
                    native_dest = "#Build/native"
                else:
                    native_dest = "#Build/native/" + configuration
                buildTargets.append(variantEnv.Install(native_dest, buildTargets))
                testTargets.append(variantEnv.Install(native_dest, testTargets))
                analyzeTargets.append(variantEnv.Install(native_dest, analyzeTargets))

                # Most developers only want to build or test with one variant on their host system.
                # These aliases make this easy. A full alias looks like `test:release`. The action
                # (`test`) defaults to `build`. The configuration (`release`) defaults to both
                # `release` and `debug`.
                AliasIfNotEmpty(configuration, buildTargets)
                AliasIfNotEmpty("build:" + configuration, buildTargets)
                AliasIfNotEmpty("test:" + configuration, testTargets)
                AliasIfNotEmpty("analyze:" + configuration, analyzeTargets)
                AliasIfNotEmpty("build", buildTargets)
                AliasIfNotEmpty("test", testTargets)
                AliasIfNotEmpty("analyze", analyzeTargets)

        # These aliases exist for developers that are looking to test their changes across multiple,
        # or specific, compilers. A full alias looks like `test:gcc_9:win32:x86:release`. The action
        # (`test`) defaults to `build`. The configuration (`release`) defaults to both `release` and
        # `debug`. arch (`x86`) and OS (`win32`) default to all available values for each. `all` can
        # be used in place of `compiler:os:arch:configuration` for all available values for each.
        AliasIfNotEmpty("all", buildTargets)
        AliasIfNotEmpty("build:all", buildTargets)
        AliasIfNotEmpty("test:all", testTargets)
        AliasIfNotEmpty("analyze:all", analyzeTargets)
        heirarchy = (compiler_name, targ_os, targ_arch, configuration)
        for heirarchyDepth in range(1, len(heirarchy) + 1):
            heirarchyName = ":".join(heirarchy[:heirarchyDepth])
            AliasIfNotEmpty(heirarchyName, buildTargets)
            AliasIfNotEmpty("build:" + heirarchyName, buildTargets)
            AliasIfNotEmpty("test:" + heirarchyName, testTargets)
            AliasIfNotEmpty("analyze:" + heirarchyName, analyzeTargets)

# The default for "scons -c" is to clean the entire Build directory; otherwise, the default is to
# build just the native debug and release targets
if GetOption("clean"):
    Default("#Build")
else:
    Default("build")
