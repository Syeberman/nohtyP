import os.path, itertools
import SCons.Errors

# TODO support scons -h for build options

# Confirm that scons' top-level directory, the current directory, _is_ the project top
if not os.path.exists( "nohtyP.c" ):
    Exit( "Run SCons from top project dir (or use make.bat, or scons -C)" )


# Adds nohtyP.dll/libnotyP.so/etc as a target in env
def nohtyP_SharedLibrary( env ):
    env.PrependUnique(
            CPPPATH=[
                "#",
                ],
            CPPDEFINES=[
                "yp_ENABLE_SHARED",
                "yp_BUILD_CORE",
                "yp_DEBUG_LEVEL=%s" % ("1" if env["CONFIGURATION"] == "debug" else "0"),
                ],
            PDB="$VTOP/nohtyP.pdb", LIBS="",
            )
    return env.SharedLibrary( "$VTOP/nohtyP", source="$VTOP/nohtyP.c" ),

def nohtyP_yp_test( env, sharedLib ):
    env.PrependENVPath( "PYTHONPATH", "#/Lib" )
    env.PrependENVPath( "PATH", sharedLib.get_dir( ) )
    scripts = ("#/Lib/yp.py", Glob("#/Lib/yp_test/*.py"), Glob("#/Lib/yp_test/*.txt"))
    testLog = env.Command( "$VTOP/yp_test.log", (sharedLib, scripts),
            "python -m yp_test -v > $TARGET" )
    Clean( sharedLib, testLog )
    return testLog


# Command-line build variables
vars = Variables( None )

# Generic build environment applicable to all compilers/targets and used internally by SCons
rootEnv = DefaultEnvironment( tools=[], variables=vars )

# Require that only known command-line variables are used
vars_unknown = vars.UnknownVariables( )
if vars_unknown: Exit( "Unknown variables: %r" % vars_unknown.keys( ) )

# Require that construction variable names exist at expansion, then add those allowed to be empty
AllowSubstExceptions( )
rootEnv.Replace( CPPFLAGS=[], SHCCCOMSTR="", SHLINKCOMSTR="", SHLIBVERSION="", LIBPATH=[], PCH="",
        WINDOWS_INSERT_DEF=0, WINDOWSDEFPREFIX="", WINDOWSDEFSUFFIX="" )

# Put .sconsign.dblite (et al) in Build rather than the top nohtyP directory
rootEnv.SConsignFile( os.path.abspath( "Build/.sconsign" ) )

# For dependencies, first consider timestamps, then MD5 checksums
rootEnv.Decider( "MD5-timestamp" )

# Always use cmd.exe on Windows, regardless of user's shell; ignored on other platforms
rootEnv["ENV"]["COMSPEC"] = "cmd.exe"

# TODO Scripts to update version numbers in source, build scripts, etc
rootEnv.Replace( NOHTYP_MAJOR=0, NOHTYP_MINOR=5, NOHTYP_PATCH=0 )


# Site-specific tool configuration.  For some tools, this caches the results of lengthy
# auto-detection; for other tools that don't have version-dependent auto-detect, this allows the
# user to tell us where they put the other versions.
siteTools_name = os.path.abspath( "Build/site-tools.py" )
siteTools_dict = {}
if not os.path.exists( siteTools_name ):
    with open( siteTools_name, "w" ) as outfile:
        outfile.write( "# Holds site-specific configuration options for the compilers and other tools.\n" )
        outfile.write( "# Edit as appropriate.  Missing entries added automatically.  Rebuilt if deleted.\n\n" )
else:
    with open( siteTools_name ) as infile:
        exec( infile.read( ), siteTools_dict )
def siteToolsFunction( ):
    """Returns the file name of site-tools.py, and a dictionary of current variables."""
    return siteTools_name, siteTools_dict
rootEnv["SITE_TOOLS"] = siteToolsFunction # a function so Clone doesn't deepcopy it


# List these in order of decreasing "preference"; the first variant that matches will be chosen as
# "native" (ie the default target)
# TODO Allow the user to specify what the "native" target should be
compiler_names = ("msvs_120", "gcc_48", "msvs_110", "msvs_100", "msvs_90")
oses = ("win32", )
archs = ("amd64", "x86")
# TODO An "analyze" configuration to use the compiler's static analysis, "lint" to explicitly use
# lint agains the compiler's headers
configurations = ("release", "debug")

native_os = rootEnv["PLATFORM"]
# TODO HOST_ARCH not supported outside of Windows
if rootEnv["HOST_ARCH"] == "x86_64":
    native_archs = ("amd64", "x86")
else:
    native_archs = (rootEnv["HOST_ARCH"], )

# The native targets ("debug", "release", etc) should each copy files from a single variant
nativeTargetsToCreate = set( ("debug", "release") )

python3 = Tool( "python_3", toolpath=["Build/Tools", ] )
for compiler_name in compiler_names:
    compiler = Tool( compiler_name, toolpath=["Build/Tools", ] )
    if not compiler.exists( rootEnv ): continue

    for targ_os, targ_arch, configuration in itertools.product( oses, archs, configurations ):
        # TODO Support cross-compiling OSes, if possible
        if targ_os != native_os: continue

        # Maintain a separate directory for intermediate and target files, but don't copy files
        variantEnv = rootEnv.Clone( COMPILER=compiler,
                TARGET_OS=targ_os, TARGET_ARCH=targ_arch, CONFIGURATION=configuration )
        variantEnv["VTOP"] = "#Build/%s/%s_%s_%s" % (
                compiler_name, targ_os, targ_arch, configuration)
        variantEnv.VariantDir( "$VTOP", "#", duplicate=False )

        # Skip compilers that can't be found (TODO unless we want an error in that case?)
        # TODO: This script is slow due to vcvarsall.bat executing 52 times; cache in SCons
        # TODO: Record compiler version information in the variant directory
        try:
            compilerEnv = variantEnv.Clone( tools=[compiler, ] )
        except (SCons.Errors.UserError, SCons.Errors.StopError): continue

        sharedLib = nohtyP_SharedLibrary( compilerEnv.Clone( ) )
        ypTest = nohtyP_yp_test( variantEnv.Clone( tools=[python3, ] ), Flatten( sharedLib )[0] )

        buildTargets = [sharedLib, ]
        testTargets = [ypTest, ]

        # Pick one variant from each configuration that matches the host system, and copy it to the
        # Build/native directory for easy access
        if targ_os == native_os and targ_arch in native_archs:
            if configuration in nativeTargetsToCreate:
                if configuration == "release":
                    native_dest = "#Build/native"
                else:
                    native_dest = "#Build/native/%s" % configuration
                # FIXME "make -c debug" not cleaning nohtyP.lib et al
                native_buildTargets = variantEnv.Install( native_dest, buildTargets )
                native_testTargets = variantEnv.Install( native_dest, testTargets )
                buildTargets.append( native_buildTargets )
                testTargets.append( native_testTargets )
                Alias( configuration, native_buildTargets )
                Alias( "test"+configuration, native_testTargets )
                Alias( "native", native_buildTargets )
                Alias( "test", native_testTargets )
                nativeTargetsToCreate.remove( configuration )

        Alias( "all", buildTargets )
        Alias( compiler_name, buildTargets )
        Alias( "_".join( (compiler_name, targ_os) ), buildTargets )
        Alias( "_".join( (compiler_name, targ_os, targ_arch) ), buildTargets )
        Alias( "_".join( (compiler_name, targ_os, targ_arch, configuration) ), buildTargets )

# If SCons is called without targets, build the "native" target
Default( Alias( "native" ) )

